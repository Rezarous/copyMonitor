<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MT5 Dashboard — Symbols × Accounts</title>
  <link rel="stylesheet" href="style.css?v=4">
</head>
<body>
  <h1>MT5 Dashboard</h1>
  <div id="out">Loading…</div>

  <script>
    const dash = (x,d=2)=>(x==null||Number.isNaN(Number(x)))?"-":Number(x).toFixed(d);
    const fmtPosLine = p => {
      const side=(p?.type||"").toUpperCase();
      const vol=dash(p?.volume);
      const plv=(p?.profit==null)?null:Number(p.profit);
      const cls=(plv==null||Number.isNaN(plv))?"":(plv>=0?"pos":"neg");
      return `<div class="line"><div>${side}: ${vol}</div><div class="pl ${cls}">${dash(plv)}</div></div>`;
    };
    const fmtTime = iso => { if(!iso) return "-"; const d=new Date(iso); return isNaN(d.getTime())?"-":d.toLocaleString(); };
    const secsSince = iso => { if(!iso) return "-"; const t=new Date(iso).getTime(); if(Number.isNaN(t)) return "-"; const s=(Date.now()-t)/1000; return s<0?"-":s.toFixed(1); };
    function pickPL(a){ if(!a) return null; if(a.profit!=null&&Number.isFinite(Number(a.profit))) return Number(a.profit);
      if(a.pl!=null&&Number.isFinite(Number(a.pl))) return Number(a.pl);
      if(a.balance!=null&&a.equity!=null){const b=Number(a.balance),e=Number(a.equity); if(Number.isFinite(b)&&Number.isFinite(e)) return e-b;}
      return null; }

    async function load(){
      const out=document.getElementById("out");
      try{
        const res=await fetch("/summary",{cache:"no-store"});
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        const data=await res.json();

        const accountsMeta=data.accounts||{};
        const volumesMap=data.volumes||{};
        const posMap=data.positions||{};
        const beMapAll=data.breakevens||{};
        const accounts=Object.keys(accountsMeta);

        if(accounts.length===0){
          out.innerHTML="<p class='muted'>No data yet. Make sure your EAs are posting to /mt5/positions.</p>";
          return;
        }

        // collect symbols present
        const symbolsSet=new Set();
        for(const acct of accounts){
          for(const s in (volumesMap[acct]||{})) symbolsSet.add(s);
          for(const p of (posMap[acct]||[])) if(p.symbol) symbolsSet.add(p.symbol);
        }
        const symbols=[...symbolsSet].sort();

        let html=`<table class="grid" style="--acct-cols:${accounts.length}">`;
        html+="<tr><th>Symbol</th>";
        for(const acct of accounts) html+=`<th>${acct}</th>`;
        html+="</tr>";

        for(const sym of symbols){
          const maxLines=Math.max(1, ...accounts.map(ac=>(posMap[ac]||[]).filter(p=>p.symbol===sym).length));
          const totalRows=maxLines+2;

          for(let i=0;i<maxLines;i++){
            if(i===0){ html+=`<tr><td rowspan="${totalRows}"><strong>${sym}</strong></td>`; }
            else { html+="<tr>"; }
            for(const acct of accounts){
              const plist=(posMap[acct]||[]).filter(p=>p.symbol===sym);
              html+= plist[i] ? `<td>${fmtPosLine(plist[i])}</td>` : `<td><span class="muted">-</span></td>`;
            }
            html+="</tr>";
          }

          // Total Vol row (no first-column cell; symbol cell already rowspans)
          html+="<tr>";
          for(const acct of accounts){
            const tv=(volumesMap[acct]||{})[sym];
            html+=`<td><div class="meta"><span class="muted">Total Vol</span> <strong>${dash(tv)}</strong></div></td>`;
          }
          html+="</tr>";

          // Break-Even row (server-computed)
          html+="<tr>";
          for(const acct of accounts){
            const be=(beMapAll[acct]||{})[sym];
            const display=(be==null||Number.isNaN(Number(be)))? "-" : Number(be).toFixed(5);
            html+=`<td><div class="meta"><span class="muted">Break-Even</span> <strong>${display}</strong></div></td>`;
          }
          html+="</tr>";
        }

        // Metrics block at bottom
        html+=`<tr class="section"><td>Metrics</td>${"<td></td>".repeat(accounts.length)}</tr>`;

        html+="<tr><td>Last Heartbeat</td>";
        for(const acct of accounts) html+=`<td>${fmtTime(accountsMeta[acct]?.iso)}</td>`;
        html+="</tr>";

        html+="<tr><td>Seconds since heartbeat</td>";
        for(const acct of accounts) html+=`<td>${secsSince(accountsMeta[acct]?.iso)}</td>`;
        html+="</tr>";

        html+="<tr><td>Current P/L</td>";
        for(const acct of accounts){
          const pl=pickPL(accountsMeta[acct]);
          const cls=(pl==null)?"":(pl>=0?"pos":"neg");
          html+=`<td class="${cls}">${dash(pl)}</td>`;
        }
        html+="</tr>";

        html+="</table>";
        out.innerHTML=html;
      }catch(err){
        out.innerHTML=`<p style="color:#b00020">Failed to load /summary: ${err.message}</p>`;
        console.error(err);
      }
    }

    setInterval(load, 1000);
    load();
  </script>
</body>
</html>
